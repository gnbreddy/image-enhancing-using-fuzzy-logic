<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fuzzy Logic Edge Corrector</title>
    <!-- Simple favicon to prevent 404 errors -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚úèÔ∏è</text></svg>">
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        canvas {
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            max-width: 100%;
            height: auto;
            background-color: #fff;
        }
        .slider-container {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border-radius: 0.5rem;
            padding: 1rem;
            color: white;
        }
        .info-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 0.5rem;
            padding: 1rem;
            color: white;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="bg-white p-8 rounded-2xl shadow-xl max-w-6xl w-full">
        <div class="flex items-center justify-between mb-6">
            <button onclick="window.location.href='index.html'" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors duration-300">
                ‚Üê Back to Home
            </button>
            <h1 class="text-3xl font-bold text-gray-800">Fuzzy Logic Edge Corrector</h1>
            <div class="w-32"></div> <!-- Spacer for centering -->
        </div>
        
        <div class="space-y-4 mb-6">
            <div class="flex flex-col items-center">
                <label for="image-upload" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-6 rounded-lg cursor-pointer transition-colors duration-300">
                    Upload Image
                </label>
                <input type="file" id="image-upload" accept="image/*" class="hidden">
                <p id="file-name" class="mt-2 text-gray-600 text-sm"></p>
            </div>
            
            <!-- Edge Correction Parameters -->
            <div class="grid md:grid-cols-3 gap-4">
                <div class="slider-container">
                    <label for="edge-threshold" class="block text-sm font-medium mb-2">Edge Sensitivity: <span id="edge-value">50</span></label>
                    <input type="range" id="edge-threshold" min="10" max="100" value="50" class="w-full">
                </div>
                <div class="slider-container">
                    <label for="correction-strength" class="block text-sm font-medium mb-2">Correction Strength: <span id="strength-value">0.6</span></label>
                    <input type="range" id="correction-strength" min="0.1" max="1.0" step="0.1" value="0.6" class="w-full">
                </div>
                <div class="slider-container">
                    <label for="gap-tolerance" class="block text-sm font-medium mb-2">Gap Tolerance: <span id="gap-value">3</span></label>
                    <input type="range" id="gap-tolerance" min="1" max="10" value="3" class="w-full">
                </div>
            </div>
            
            <div class="flex gap-4">
                <button id="detect-btn" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg transition-colors duration-300 shadow-lg" disabled>
                    Detect Edges
                </button>
                <button id="correct-btn" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg transition-colors duration-300 shadow-lg" disabled>
                    Correct Defective Edges
                </button>
            </div>
        </div>

        <div id="loading-indicator" class="hidden text-center text-gray-500 mb-4">
            <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-red-500"></div>
            <p class="mt-2">Processing edges...</p>
        </div>

        <div class="grid md:grid-cols-3 gap-6">
            <div class="flex flex-col items-center">
                <h2 class="text-xl font-semibold mb-2">Original Image</h2>
                <canvas id="original-canvas"></canvas>
            </div>
            <div class="flex flex-col items-center">
                <h2 class="text-xl font-semibold mb-2">Edge Detection</h2>
                <canvas id="edge-canvas"></canvas>
            </div>
            <div class="flex flex-col items-center">
                <h2 class="text-xl font-semibold mb-2">Corrected Image</h2>
                <canvas id="corrected-canvas"></canvas>
            </div>
        </div>
        
        <!-- Download Section -->
        <div id="download-section" class="hidden mt-8 text-center">
            <button id="download-btn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-8 rounded-lg transition-colors duration-300 shadow-lg">
                üì• Download Edge-Corrected Image
            </button>
            <p class="mt-2 text-gray-600 text-sm">Download your edge-corrected image</p>
        </div>

        <div class="mt-6 info-panel">
            <h3 class="font-semibold mb-2">Fuzzy Logic Edge Correction Process:</h3>
            <div class="text-sm space-y-1">
                <p><strong>1. Edge Detection:</strong> Uses Sobel operators to detect edge gradients</p>
                <p><strong>2. Defect Classification:</strong> Fuzzy sets classify edges as Strong, Weak, or Broken</p>
                <p><strong>3. Gap Analysis:</strong> Identifies discontinuities in edge structures</p>
                <p><strong>4. Intelligent Repair:</strong> Applies contextual interpolation to fix defective edges</p>
                <p><strong>5. Preservation:</strong> Maintains strong edges while repairing weak/broken ones</p>
            </div>
        </div>
    </div>

    <script>
        // Get references to all the DOM elements
        const imageUpload = document.getElementById('image-upload');
        const fileNameDisplay = document.getElementById('file-name');
        const detectBtn = document.getElementById('detect-btn');
        const correctBtn = document.getElementById('correct-btn');
        const originalCanvas = document.getElementById('original-canvas');
        const edgeCanvas = document.getElementById('edge-canvas');
        const correctedCanvas = document.getElementById('corrected-canvas');
        const loadingIndicator = document.getElementById('loading-indicator');
        
        // Parameter controls
        const edgeThreshold = document.getElementById('edge-threshold');
        const correctionStrength = document.getElementById('correction-strength');
        const gapTolerance = document.getElementById('gap-tolerance');
        const edgeValue = document.getElementById('edge-value');
        const strengthValue = document.getElementById('strength-value');
        const gapValue = document.getElementById('gap-value');
        
        const originalCtx = originalCanvas.getContext('2d');
        const edgeCtx = edgeCanvas.getContext('2d');
        const correctedCtx = correctedCanvas.getContext('2d');
        
        let originalImage = null;
        let edgeData = null;

        // Update slider values display
        edgeThreshold.addEventListener('input', (e) => {
            edgeValue.textContent = e.target.value;
        });

        correctionStrength.addEventListener('input', (e) => {
            strengthValue.textContent = e.target.value;
        });

        gapTolerance.addEventListener('input', (e) => {
            gapValue.textContent = e.target.value;
        });

        // Event listener for the file input
        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                fileNameDisplay.textContent = file.name;
                detectBtn.disabled = true;
                correctBtn.disabled = true;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    originalImage = new Image();
                    originalImage.onload = () => {
                        // Set canvas sizes to match the image
                        const width = originalImage.width;
                        const height = originalImage.height;
                        
                        originalCanvas.width = width;
                        originalCanvas.height = height;
                        edgeCanvas.width = width;
                        edgeCanvas.height = height;
                        correctedCanvas.width = width;
                        correctedCanvas.height = height;
                        
                        // Draw the original image
                        originalCtx.drawImage(originalImage, 0, 0);
                        edgeCtx.clearRect(0, 0, width, height);
                        correctedCtx.clearRect(0, 0, width, height);
                        
                        detectBtn.disabled = false;
                    };
                    originalImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Event listener for edge detection
        detectBtn.addEventListener('click', () => {
            if (originalImage) {
                loadingIndicator.classList.remove('hidden');
                detectBtn.disabled = true;
                
                setTimeout(() => {
                    detectEdges();
                    loadingIndicator.classList.add('hidden');
                    detectBtn.disabled = false;
                    correctBtn.disabled = false;
                }, 100);
            }
        });

        // Event listener for edge correction
        correctBtn.addEventListener('click', () => {
            if (originalImage && edgeData) {
                loadingIndicator.classList.remove('hidden');
                correctBtn.disabled = true;
                
                setTimeout(() => {
                    correctEdges();
                    loadingIndicator.classList.add('hidden');
                    correctBtn.disabled = false;
                }, 100);
            }
        });

        // Event listener for the download button
        document.getElementById('download-btn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'edge_corrected_image.png';
            link.href = correctedCanvas.toDataURL();
            link.click();
        });

        /**
         * Detect edges using Sobel operators and fuzzy logic classification.
         */
        function detectEdges() {
            const imageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
            const data = imageData.data;
            const width = originalCanvas.width;
            const height = originalCanvas.height;
            
            // Convert to grayscale first
            const grayData = new Array(width * height);
            for (let i = 0; i < data.length; i += 4) {
                const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                grayData[i / 4] = gray;
            }
            
            // Apply Sobel edge detection
            const edgeStrengths = new Array(width * height);
            const threshold = parseInt(edgeThreshold.value);
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    
                    // Sobel X kernel
                    const gx = (-1 * grayData[(y-1)*width + (x-1)]) + 
                              (1 * grayData[(y-1)*width + (x+1)]) +
                              (-2 * grayData[y*width + (x-1)]) + 
                              (2 * grayData[y*width + (x+1)]) +
                              (-1 * grayData[(y+1)*width + (x-1)]) + 
                              (1 * grayData[(y+1)*width + (x+1)]);
                    
                    // Sobel Y kernel
                    const gy = (-1 * grayData[(y-1)*width + (x-1)]) + 
                              (-2 * grayData[(y-1)*width + x]) +
                              (-1 * grayData[(y-1)*width + (x+1)]) +
                              (1 * grayData[(y+1)*width + (x-1)]) + 
                              (2 * grayData[(y+1)*width + x]) +
                              (1 * grayData[(y+1)*width + (x+1)]);
                    
                    // Calculate edge magnitude
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    edgeStrengths[idx] = magnitude;
                }
            }
            
            // Store edge data for correction phase
            edgeData = {
                strengths: edgeStrengths,
                grayData: grayData,
                width: width,
                height: height
            };
            
            // Visualize edges with fuzzy classification
            const edgeImageData = edgeCtx.createImageData(width, height);
            const edgePixels = edgeImageData.data;
            
            for (let i = 0; i < edgeStrengths.length; i++) {
                const strength = edgeStrengths[i];
                const fuzzyEdge = fuzzyEdgeClassification(strength, threshold);
                
                // Color code: Strong edges = white, Weak edges = gray, Broken = red
                let r, g, b;
                if (fuzzyEdge.strong > 0.5) {
                    r = g = b = 255; // White for strong edges
                } else if (fuzzyEdge.weak > 0.3) {
                    r = g = b = 128; // Gray for weak edges
                } else {
                    r = 255; g = b = 0; // Red for potential breaks
                }
                
                edgePixels[i * 4] = r;
                edgePixels[i * 4 + 1] = g;
                edgePixels[i * 4 + 2] = b;
                edgePixels[i * 4 + 3] = 255;
            }
            
            edgeCtx.putImageData(edgeImageData, 0, 0);
        }

        /**
         * Fuzzy classification of edge strength.
         */
        function fuzzyEdgeClassification(strength, threshold) {
            // Optimized for screenshot edges (text, UI elements, etc.)
            const strongEdge = sigmoidMembership(strength, threshold * 1.2, 12);
            const weakEdge = triangularMembership(strength, threshold * 0.2, threshold * 0.8, threshold * 1.3);
            const brokenEdge = trapezoidalMembership(strength, 0, 0, threshold * 0.25, threshold * 0.5);
            
            return {
                strong: strongEdge,
                weak: weakEdge,
                broken: brokenEdge
            };
        }

        /**
         * Correct defective edges using fuzzy logic.
         */
        function correctEdges() {
            const imageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
            const data = imageData.data;
            const correctedData = new Uint8ClampedArray(data);
            
            const width = edgeData.width;
            const height = edgeData.height;
            const threshold = parseInt(edgeThreshold.value);
            const strength = parseFloat(correctionStrength.value);
            const gapTol = parseInt(gapTolerance.value);
            
            // Process each pixel for edge correction
            for (let y = gapTol; y < height - gapTol; y++) {
                for (let x = gapTol; x < width - gapTol; x++) {
                    const idx = y * width + x;
                    const pixelIdx = idx * 4;
                    
                    const edgeStrength = edgeData.strengths[idx];
                    const fuzzyEdge = fuzzyEdgeClassification(edgeStrength, threshold);
                    
                    // Apply correction based on fuzzy classification
                    if (fuzzyEdge.broken > 0.3 || fuzzyEdge.weak > 0.5) {
                        const correction = fuzzyEdgeCorrection(
                            data, x, y, width, height, fuzzyEdge, strength, gapTol
                        );
                        
                        if (correction) {
                            correctedData[pixelIdx] = correction.r;
                            correctedData[pixelIdx + 1] = correction.g;
                            correctedData[pixelIdx + 2] = correction.b;
                        }
                    }
                }
            }
            
            // Draw corrected image
            const correctedImageData = new ImageData(correctedData, width, height);
            correctedCtx.putImageData(correctedImageData, 0, 0);
            
            // Show download section
            document.getElementById('download-section').classList.remove('hidden');
        }

        /**
         * Apply fuzzy logic edge correction.
         */
        function fuzzyEdgeCorrection(data, x, y, width, height, fuzzyEdge, strength, gapTol) {
            const pixelIdx = (y * width + x) * 4;
            const originalR = data[pixelIdx];
            const originalG = data[pixelIdx + 1];
            const originalB = data[pixelIdx + 2];
            
            // Find neighboring strong edges for interpolation
            const neighbors = findStrongNeighbors(data, x, y, width, height, gapTol);
            
            if (neighbors.length < 2) {
                return null; // Not enough context for correction
            }
            
            // Calculate interpolated values based on neighboring strong edges
            let avgR = 0, avgG = 0, avgB = 0;
            let totalWeight = 0;
            
            neighbors.forEach(neighbor => {
                const weight = 1 / (neighbor.distance + 1); // Distance-based weighting
                avgR += neighbor.r * weight;
                avgG += neighbor.g * weight;
                avgB += neighbor.b * weight;
                totalWeight += weight;
            });
            
            if (totalWeight > 0) {
                avgR /= totalWeight;
                avgG /= totalWeight;
                avgB /= totalWeight;
            }
            
            // Fuzzy rules for correction
            const brokenCorrection = fuzzyEdge.broken * strength;
            const weakCorrection = fuzzyEdge.weak * strength * 0.5;
            const totalCorrection = Math.min(1, brokenCorrection + weakCorrection);
            
            // Blend original and corrected values
            const newR = originalR * (1 - totalCorrection) + avgR * totalCorrection;
            const newG = originalG * (1 - totalCorrection) + avgG * totalCorrection;
            const newB = originalB * (1 - totalCorrection) + avgB * totalCorrection;
            
            return {
                r: Math.min(255, Math.max(0, Math.round(newR))),
                g: Math.min(255, Math.max(0, Math.round(newG))),
                b: Math.min(255, Math.max(0, Math.round(newB)))
            };
        }

        /**
         * Find strong neighboring edges for interpolation.
         */
        function findStrongNeighbors(data, x, y, width, height, radius) {
            const neighbors = [];
            const threshold = parseInt(edgeThreshold.value);
            
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const nIdx = ny * width + nx;
                        const edgeStrength = edgeData.strengths[nIdx];
                        const fuzzyEdge = fuzzyEdgeClassification(edgeStrength, threshold);
                        
                        if (fuzzyEdge.strong > 0.5) {
                            const pixelIdx = nIdx * 4;
                            neighbors.push({
                                r: data[pixelIdx],
                                g: data[pixelIdx + 1],
                                b: data[pixelIdx + 2],
                                distance: Math.sqrt(dx * dx + dy * dy)
                            });
                        }
                    }
                }
            }
            
            return neighbors;
        }

        /**
         * Sigmoid membership function for smooth transitions.
         */
        function sigmoidMembership(x, center, steepness) {
            return 1 / (1 + Math.exp(-steepness * (x - center) / center));
        }

        /**
         * Triangular membership function.
         */
        function triangularMembership(x, a, m, b) {
            if (x <= a || x >= b) {
                return 0;
            } else if (x >= a && x <= m) {
                return (x - a) / (m - a);
            } else if (x >= m && x <= b) {
                return (b - x) / (b - m);
            }
            return 0;
        }

        /**
         * Trapezoidal membership function.
         */
        function trapezoidalMembership(x, a, m1, m2, b) {
            if (x <= a || x >= b) {
                return 0;
            } else if (x >= m1 && x <= m2) {
                return 1;
            } else if (x > a && x < m1) {
                return (x - a) / (m1 - a);
            } else if (x > m2 && x < b) {
                return (b - x) / (b - m2);
            }
            return 0;
        }
    </script>
</body>
</html>